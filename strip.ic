/**
 * @file   strip.ic
 * @brief  Follow metal strip
 * @author Joel Friedly
 * @date   4/30/2011
 */

#use "gps.ic"
#use "opto.ic"

#define STRIP_PORT_LEFT 4
#define STRIP_PORT_MIDDLE 5
#define STRIP_PORT_RIGHT 6
#define STRIP_THRESHOLD 250
#define THREE_SIXTY 64.0
#define CLOCKWISE 8675309
#define CTRCLOCKWISE 1337
#define BOTH 2



// Use the 360 degree compass for [angle]
void align_with_strip(int angle)
{
    int theta, trans_to_turn, i, j;
    
    theta = abs(robot_heading - angle);
    
    // if the robot is more than 2 degrees off course, turn a little bit
    while(theta > 2)
      {
        trans_to_turn = (int)(THREE_SIXTY * ((float)theta/360.0));
        /* NOTE:  with the requirement that theta must be greater than 2, the smallest value of theta in the above math is 
        3.0.  Using 3.0, the float math will evaluate to 0.533, which will typecast to th6e integer 1, so trans_to_turn 
        will always be 1 or more. */
        
        if(robot_heading < angle)
          {
            i=0;
            
            while((analog(STRIP_PORT_LEFT) > STRIP_THRESHOLD) && (i < trans_to_turn))
              {
                // turn clockwise to angle
                go_by_transitions(1, CLOCKWISE);
                ++i;
            }
        }
        
        else if(robot_heading > angle)
          {
            j=0;
            
            while((analog(STRIP_PORT_RIGHT) > STRIP_THRESHOLD) && (j < trans_to_turn))
              {
                // turn clockwise to angle
                go_by_transitions(1, CTRCLOCKWISE);
                ++j;
            }
        }
        
        theta = abs(robot_heading - angle); 
    } 
}

int main()
{
    int readingL, readingM, readingR;
    while(!start_button());
    
    while(!stop_button())
      {
        readingL=analog(STRIP_PORT_LEFT);
        readingM=analog(STRIP_PORT_MIDDLE);
        readingR=analog(STRIP_PORT_RIGHT);
        printf("L=%d M=%d R=%d\n", readingL, readingM, readingR);
        sleep(0.05);
    } 
    
    align_with_strip(90);
    while(analog(STRIP_PORT_LEFT) > STRIP_THRESHOLD || analog(STRIP_PORT_LEFT) > STRIP_THRESHOLD)
      go_by_transitions(1, BOTH);
    
}
