/**
 * @file drive.ic
 * @brief Driving code.  Way too much stuff is currently in here
 * @author Andrew Krieger
 * @date 4/25/2011
 */

#use "defines.ic"
#use "util.ic"
#use "line.ic"
#use "gps.ic"
#use "servo/exp_servo_lib.ic"

/// Wait for this many loops to confirm we're over something shiny (ie, aluminum strips)
#define SHINY_TIME 1


/**
 * @brief Drive up the hill
 *
 * Assume that the robot starts facing approximately north, in the starting
 * area.  This code angles to the right upo the hill, using the right wall
 * switch to detect the wall.  By hugging the wall, the robot avoids getting
 * caught in the tilled field.
 */
void drive_up_hill() {
    //number of cycles for which the tested optosensors are over something shiny
    //The sensors will occasionally return low numbers when over a screw in the course
    // And sometimes
    int shiny_ctr;
    
    printf("Going up hill\n");
    
    //Drive across the bumps and up the hill - angle right when off wall
    motor(MOTOR_LEFT, 100);
    reset_system_time();
    while(shiny_ctr < SHINY_TIME && !start_button() && mseconds() < 5500L) {
        //If the switch is pressed, go straight.  Otherwise angle right.
        if(digital(SWITCH_WALL_RIGHT))
          motor(MOTOR_RIGHT,100);
        else
          motor(MOTOR_RIGHT, 90);
        
        //Check the optos
        if(analog(OPTO_FRONT_RIGHT) < OPTO_THRESHOLD && analog(OPTO_FRONT_LEFT) < OPTO_THRESHOLD) {
            ++shiny_ctr;
        } else {
            shiny_ctr = 0;
        }
    }
    
    printf("Front on shiny\n");
    //Go straight (ish) until the front sensors are off the shiny
    motor(MOTOR_RIGHT, 100);
    reset_system_time();
    while((analog(OPTO_FRONT_LEFT) < OPTO_THRESHOLD || analog(OPTO_FRONT_RIGHT) < OPTO_THRESHOLD) && !start_button() && mseconds() < 500L)
      ;
    
    printf("Looking for back\n");
    //Go straight (ish) until the rear optos are on the shiny
    shiny_ctr = 0;
    reset_system_time();
    while(shiny_ctr < SHINY_TIME && !start_button() && mseconds() < 1000L) {
        if(analog(OPTO_BACK_RIGHT) < OPTO_THRESHOLD && analog(OPTO_BACK_LEFT) < OPTO_THRESHOLD) {
            ++shiny_ctr;
        } else {
            shiny_ctr = 0;
        }
    }
    
    //Stop
    ao();    
}


/**
 * @brief Return to start area from hill
 *
 * Assume that the robot starts facing south, above the start area.
 * This code drives approximately straight, only angling a bit to the
 * right in order to hug the wall.
 * This code also takes care of pushing the END BUTTON.
 */
void drive_down_hill() {
    int i;
    
    printf("Going down hill\n");
    
    //Drive across the bumps and up the hill - angle right when off wall
    motor(MOTOR_RIGHT, 90);
    while(digital(SWITCH_FRONT_LEFT)) {
        //If the switch is pressed, go straight.  Otherwise angle right.
        if(digital(SWITCH_WALL_LEFT))
          motor(MOTOR_LEFT,90);
        else
          motor(MOTOR_LEFT, 75);
    }
    
    for(i=0; i<7; ++i) {
        motor(MOTOR_LEFT, 100);
        motor(MOTOR_RIGHT, 100);
        msleep(1000L);
        motor(MOTOR_LEFT, -100);
        motor(MOTOR_RIGHT, -100);
        msleep(500L);
    }
    
}


/**
 * @brief Control motors to compensate for encoders
 * @param disparity The maximum difference in shaft encoder counts before stopping the advanced motor
 *
 * Runs the left and right motors at various speeds in order to go (approximately) straight
 * back, according to the shaft encoders.  Note that this leaves the motors running.
 */
void step_straight_back(int disparity) {
    int low_power;
    
    if(abs(SHAFT_LEFT_COUNT - SHAFT_RIGHT_COUNT) > disparity)
      low_power = 0;
    else
      low_power = 50;
    
    if(SHAFT_LEFT_COUNT > SHAFT_RIGHT_COUNT) {
        motor(MOTOR_LEFT,  -low_power);
        motor(MOTOR_RIGHT, -100);
        
    } else if(SHAFT_LEFT_COUNT < SHAFT_RIGHT_COUNT) {
        motor(MOTOR_LEFT, -100);
        motor(MOTOR_RIGHT, -low_power);
    } else {
        motor(MOTOR_LEFT,  -100);
        motor(MOTOR_RIGHT, -100);
    }
}

/**
 * @brief Control motors to compensate for encoders
 * @param disparity The maximum difference in shaft encoder counts before stopping the advanced motor
 *
 * Runs the left and right motors at various speeds in order to go
 * straight, according to the shft encoders.  Note that this leaves the motors running.
 */
void step_straight_forward(int disparity) {
    int low_power;
    
    if(abs(SHAFT_LEFT_COUNT - SHAFT_RIGHT_COUNT) > disparity)
      low_power = 0;
    else
      low_power = 50;
    
    if(SHAFT_LEFT_COUNT > SHAFT_RIGHT_COUNT) {
        motor(MOTOR_LEFT,  low_power);
        motor(MOTOR_RIGHT, 100);
    } else if(SHAFT_LEFT_COUNT < SHAFT_RIGHT_COUNT) {
        motor(MOTOR_LEFT, 100);
        motor(MOTOR_RIGHT, low_power);
    } else {
        motor(MOTOR_LEFT,  100);
        motor(MOTOR_RIGHT, 100);
    }
}

/**
 * @brief Drive backwards to reach a metal strip.
 *
 * @param go_to_front Set to nonzero to continue driving backwards until the front optos are on a strip
 * @param timeout The maximum number of miliseconds to run
 *
 * Drives straight back using shaft encoders until a metal strip is found.
 * If go_to_front is nonzero, then this will end with the front opotsensors
 * on a strip (unless the timeout is reached, of course).  If go_to_front is zero,
 * then this function will return with the back optos on a line.
 */
void drive_back_to_shiny(int go_to_front, long timeout) {
    int shiny_ctr = 0;
    int high_water = 0;
    
    printf("Where's the shiny? Backward\n");
    
    reset_system_time();
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    
    while(shiny_ctr < SHINY_TIME && !stop_button() && mseconds() < timeout) {
        if(analog(OPTO_BACK_LEFT) < OPTO_THRESHOLD && analog(OPTO_BACK_RIGHT) < OPTO_THRESHOLD) {
            ++shiny_ctr;
        } else {
            shiny_ctr = 0;
        }
        
        step_straight_back(3);
    }
    
    if(go_to_front) {
        int l,r;
        
        l=r=-1;
        
        printf("Going til back off\n");
        //Continue until the back optos are off of the shiny
        SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
        while((analog(OPTO_BACK_LEFT) < OPTO_THRESHOLD || analog(OPTO_BACK_RIGHT) < OPTO_THRESHOLD) && mseconds() < timeout)
          step_straight_back(3);
        
        ao();
        //        exp_servo_deg(0, 5);
        //        exp_servo_deg(0, 5);
        //        msleep(250L);
        
        printf("Finding front optos\n");
        SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
        shiny_ctr = 0;
        while(shiny_ctr < SHINY_TIME && mseconds() < timeout) {
            if(l!=analog(OPTO_FRONT_LEFT) || r!=analog(OPTO_FRONT_RIGHT)) {
                l = analog(OPTO_FRONT_LEFT);
                r = analog(OPTO_FRONT_RIGHT);
                printf("%d %d\n", l, r);
            }
            
            if(analog(OPTO_FRONT_LEFT) < OPTO_THRESHOLD && analog(OPTO_FRONT_RIGHT) < OPTO_THRESHOLD) {
                ++shiny_ctr;
            } else {
                shiny_ctr = 0;
            }
            
            step_straight_back(3);
        }
        
        printf("Found front optos: %d %d\n", analog(OPTO_FRONT_LEFT), analog(OPTO_FRONT_RIGHT));
    }
    
    ao();
}

/**
 * @brief Drive forwards to reach a metal strip.
 *
 * @param timeout The maximum number of miliseconds to run
 *
 * Drives straight forward using shaft encoders until a metal strip is found.
 * If go_to_front is nonzero, then this will end with the front opotsensors
 * on a strip (unless the timeout is reached, of course).  If go_to_front is zero,
 * then this function will return with the back optos on a line.
 */
void drive_forward_to_shiny(long timeout) {
    int shiny_ctr = 0;
    int high_water = 0;
    
    printf("Where's the shiny? Forward\n");
    
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    
    reset_system_time();
    while(shiny_ctr < SHINY_TIME && !stop_button() && mseconds() < timeout) {
        if(analog(OPTO_FRONT_LEFT) < OPTO_THRESHOLD && analog(OPTO_FRONT_RIGHT) < OPTO_THRESHOLD) {
            ++shiny_ctr;
        } else {
            shiny_ctr = 0;
        }
        
        step_straight_forward(4);
    }
    
    //Continue until the back optos are off of the shiny
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    while((analog(OPTO_BACK_LEFT) < OPTO_THRESHOLD || analog(OPTO_BACK_RIGHT) < OPTO_THRESHOLD) && mseconds() < timeout)
      step_straight_forward(4);
    
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    shiny_ctr = 0;
    while(shiny_ctr < SHINY_TIME && !stop_button() && mseconds() < timeout) {
        if(analog(OPTO_BACK_LEFT) < OPTO_THRESHOLD && analog(OPTO_BACK_RIGHT) < OPTO_THRESHOLD) {
            ++shiny_ctr;
        } else {
            shiny_ctr = 0;
        }
        
        step_straight_forward(4);
    }
    
    ao();
}

/**
 * @brief Angle right until a metallic strip is found
 * @deprecated This doesn't use shaft encoders or timeouts.  I also don't think it's used anywhere.
 * It probably shouldn't be.
 * 
 * Run the motors at unequal (but constant) power in order to angle right while
 * travelling forward.  Stop with both fron optosensors on the strip.
 */
void angle_right_to_shiny(void) {
    int shiny_ctr = 0;
    
    //    printf("Drive to shiny. Angle right\n");
    
    motor(MOTOR_LEFT,  80);
    motor(MOTOR_RIGHT, 100);
    
    while(shiny_ctr < SHINY_TIME && !stop_button()) {
        if(analog(OPTO_FRONT_LEFT) < OPTO_THRESHOLD && analog(OPTO_FRONT_RIGHT) < OPTO_THRESHOLD) {
            ++shiny_ctr;
        } else {
            shiny_ctr = 0;
        }
        
        //        if(mseconds() >= 50L) {
        //            printf("%d %d\n", analog(OPTO_FRONT_LEFT), analog(OPTO_FRONT_RIGHT));
        //            reset_system_time();
        //        }
        
    }
    
    ao();
    
}



///**
// * @brief Align self with metal strip
// * @deprecated Is this used anywhere?
// */
//void drive_strip() {
//    while(!stop_button()) {
//        int i;
//        
//        for(i=2;i<7;++i) {
//            printf("%d",i);
//            print_hex_byte(analog(i));
//            printf(" ");
//        }
//        
//        printf("\n");
//        sleep(0.1);
//    }
//}

/**
 * @brief Turn by deg, relative to current position
 * @param deg Degrees to turn.  Positive is CCW, negative is CW.
 *
 * This will repeatedly call [c]cw_degrees to turn.
 */
void turn(float deg) {
    if(deg > 0.0) {
        while(deg > 45.0) {
            ccw_degrees(45.0);
            deg -= 45.0;
        }
        
        ccw_degrees(deg);
    } else if(deg < 0.0) {
        while(deg < -45.0) {
            cw_degrees(45.0);
            deg += 45.0;
        }
        
        cw_degrees(-deg);
    }
}

/** 
 * @brief Attempt to turn a given number of degrees counterclockwise
 * @param deg Number of degrees to turn (must be nonnegative)
 *
 * This function ought to turn exactly deg degrees counterclockwise, but
 * it hasn't been measured too recently.  Exactly how accurate it is is not
 * currently known.
 */
void ccw_degrees(float deg) {
    //int left_trans = round(deg * (70.0 / 360.0));
    //int right_trans = round(deg * (124.0 / 360.0));
    int left_trans = round(deg * (92.5 / 360.0));
    int right_trans = round(deg * (92.5 / 360.0));
    int disp_l, disp_r;
    
    //    printf("Turning %f deg\n", deg);
    
    reset_system_time();
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    
    motor(MOTOR_LEFT, -100);
    motor(MOTOR_RIGHT, 100);
    
    while(((right_trans - SHAFT_RIGHT_COUNT) + (left_trans - SHAFT_LEFT_COUNT))/2 > 0 && mseconds() < 5000L)
      {
        /*
        if(SHAFT_LEFT_COUNT != disp_l || SHAFT_RIGHT_COUNT != disp_r) 
          {
            disp_l = SHAFT_LEFT_COUNT;
            disp_r = SHAFT_RIGHT_COUNT;
            printf("L:%d R:%d\n", disp_l, disp_r);
        }
        */
    }
    
    ao();
}
/** 
 * @brief Attempt to turn a given number of degrees clockwise
 * @param deg Number of degrees to turn (must be nonnegative)
 *
 * This function ought to turn exactly deg degrees clockwise, but
 * it hasn't been measured too recently.  Exactly how accurate it is is not
 * currently known.
 */
void cw_degrees(float deg) {
    //int left_trans = round(deg * (106.0 / 360.0));
    //int right_trans = round(deg * (95.0 / 360.0));
    int left_trans = round(deg * (92.5 / 360.0));
    int right_trans = round(deg * (92.5 / 360.0));
    int disp_l, disp_r;
    int diff_l, diff_r;
    
    //    printf("Turning %f deg\n", deg);
    
    reset_system_time();
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    
    while(mseconds() < 5000L)
      {
        diff_l = SHAFT_LEFT_COUNT - left_trans;
        diff_r = SHAFT_RIGHT_COUNT - right_trans;
        
        if(diff_l + diff_r > 1)
          break;
        
        //        if(diff_l > diff_r + 1)
        //          {
        //            motor(MOTOR_LEFT, 70);
        //            motor(MOTOR_RIGHT, -100);
        //        }
        //        else if(diff_l >= diff_r - 1)
        //          {
        motor(MOTOR_LEFT, 100);
        motor(MOTOR_RIGHT, -100);
        //        }
        //        else
        //        {
        //            motor(MOTOR_LEFT, 100);
        //            motor(MOTOR_RIGHT, -70);
        //        }
        
        /*        if(SHAFT_LEFT_COUNT != disp_l || SHAFT_RIGHT_COUNT != disp_r) 
          {
            disp_l = SHAFT_LEFT_COUNT;
            disp_r = SHAFT_RIGHT_COUNT;
            printf("L:%d R:%d\n", disp_l, disp_r);
        }
*/
    }
    
    ao();
}

/**
 * @brief Rotate clockwise to find a metal strip
 * @deprecated Replace by dancing and shaft encoder/GPS turns
 */
void turn_cw_to_shiny(void) {
    while(analog(OPTO_FRONT_LEFT) > OPTO_THRESHOLD) {
        cw_degrees(5.0);
    }
}
/*
void align_toward_start(void) {
    turn(-45.0);
    //Align facing right.  GPS should go to 90
    for(;;) {
        gps_good_data();
        
        printf("Heading: %d\n", gps_heading);
        if(abs(gps_heading - 90) < 5)
          break;
        
        if(gps_heading < 90)
          ccw_degrees(5.0);
        else
          cw_degrees(5.0);
    }
    
    
    printf("Facing east\n");
    press_start();
    //Drive to GPS x=-36, approximately
    for(;;) {
        gps_good_data();
        
        printf("X:0 %d\n", gps_x);
        if(gps_x <= -36 && gps_x >= -40)
          break;
        
        if(gps_x > -38)
          step_treads(-2, -2);
        else
          step_treads(2, 2);
    }
    
    printf("To X\n");
    press_start();
    //Turn facing southeast - GPS to 45
    for(;;) {
        gps_good_data();
        
        printf("Hdg: %d\n", gps_heading);
        
        if(abs(gps_heading - 45) < 5)
          break;
        
        if(gps_heading > 45 && gps_heading < 135)
          cw_degrees(5.0);
        else
          ccw_degrees(5.0);
    }
    
    
}

void get_to_start(void) {
    align_toward_start();
}

void turn_to_135(void) {
    turn(-20.0);
    
    for(;;) {
        gps_good_data();
        
        printf("Hdg: %d\n", gps_heading);
        
        if(abs(gps_heading - 45) < 5)
          break;
        
        if(gps_heading > 45 && gps_heading < 135)
          cw_degrees(5.0);
        else
          ccw_degrees(5.0);
    }
}




void drive_back_to_wall(void) {
    while(!digital(SWITCH_BACK_LEFT) || !digital(SWITCH_BACK_RIGHT)) {
        if(!digital(SWITCH_BACK_LEFT))
          motor(MOTOR_LEFT, -100);
        else
          motor(MOTOR_LEFT, 0);
        
        if(!digital(SWITCH_BACK_RIGHT))
          motor(MOTOR_RIGHT, -100);
        else
          motor(MOTOR_RIGHT, 0);
        
    }
}



int get_target_x(void) {
    // The line that gets us between the bumps is the solution of:
    //    y = f(x) = 60 - x
    // Solving for x as a function of y gives:
    //    x = g(y) = 60 - y
    // This line was caluclated from the two points (-30, 90) and (-45, 105)
    
    return 60 - gps_y; // f(gps_x)
}

void align_corn_to_start(void) {
    int target_x;
    //Use the GPS to face approximately east?
    
    printf("Back to wall\n");
    //Use the wall to square up
    drive_back_to_wall();
    
    //Drive to proper (x,y) coordinate
    gps_good_data();
    target_x = get_target_x();
    while(abs(gps_x - target_x) > 0) {
        printf("GPS:(%d,%d) To:%d\n", gps_x, gps_y, target_x);
        if(gps_x > target_x)
          step_treads(-1, -1);
        else
          step_treads(1, 1);
        
        gps_good_data();
        target_x = get_target_x();
    }
    
    //Face toward bumps
    turn_to_135();
}

void ctrclockwise_18(void) {
    int diff_l, diff_r;
    
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    
    motor(MOTOR_LEFT, -100);
    motor(MOTOR_RIGHT, 100);
    
    for(;;)
      {
        diff_l = SHAFT_LEFT_COUNT - 3;
        diff_r = SHAFT_RIGHT_COUNT - 3;
        
        if(diff_l + diff_r > 0)
          break;
        
    }
    
    ao();
    msleep(100L);
}  

void clockwise_18(void) {
    int diff_l, diff_r;
    
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    
    motor(MOTOR_LEFT, 100);
    motor(MOTOR_RIGHT, -100);
    
    for(;;)
      {
        diff_l = SHAFT_LEFT_COUNT - 3;
        diff_r = SHAFT_RIGHT_COUNT - 3;
        
        if(diff_l + diff_r > 0)
          break;
        
    }
    
    ao();
    msleep(100L);
}
*/


/**
 * @brief Turn by deg, relative to current position
 * @param deg Degrees to turn.  Positive is CCW, negative is CW.
 *
 * This will repeatedly call [c]cw_degrees to turn.  This turns with less motor power
 * than the regular @ref turn function.
 */
void turn_slow(float deg) {
    if(deg > 0.0) {
        while(deg > 45.0) {
            ccw_degrees_slow(45.0);
            deg -= 45.0;
        }
        
        ccw_degrees_slow(deg);
    } else if(deg < 0.0) {
        while(deg < -45.0) {
            cw_degrees_slow(45.0);
            deg += 45.0;
        }
        
        cw_degrees_slow(-deg);
    }
}

/**
 * @brief Helper function to slowly turn counterclockwise
 * @param deg Number of degrees to turn (must be nonnegative)
 */
void ccw_degrees_slow(float deg) {
    int left_trans = round(deg * (92.5 / 360.0));
    int right_trans = round(deg * (92.5 / 360.0));
    int diff_l, diff_r;
    
    //    printf("Turning %f deg\n", deg);
    
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    reset_system_time();
    
    while(mseconds() < 2000L)
      {
        diff_l = SHAFT_LEFT_COUNT - left_trans;
        diff_r = SHAFT_RIGHT_COUNT - right_trans;
        
        if(diff_l + diff_r > 1)
          break;
        
        motor(MOTOR_LEFT, -70);
        motor(MOTOR_RIGHT, 70);
        
    }
    
    ao();
}

/**
 * @brief Helper function to slowly turn clockwise.
 * @param deg Number of degrees to turn (must be nonnegative) 
 */
void cw_degrees_slow(float deg) {
    
    int left_trans = round(deg * (92.5 / 360.0));
    int right_trans = round(deg * (92.5 / 360.0));
    int disp_l, disp_r;
    int diff_l, diff_r;
    
    reset_system_time();
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    
    while(mseconds() < 2000L)
      {
        diff_l = SHAFT_LEFT_COUNT - left_trans;
        diff_r = SHAFT_RIGHT_COUNT - right_trans;
        
        if(diff_l + diff_r > 1)
          break;
        
        motor(MOTOR_LEFT, 70);
        motor(MOTOR_RIGHT, -70);
        
    }
    
    ao();
}

/**
 * @brief Turn left, right, left, ..., until we find a metal strip (or give up)
 *
 * Starts out by rotating the motors one shaft encoder transition clockwise, then 3
 * counts counterclockwise, 5 clockwise, etc.  Stops when the back optos find a metal
 * strip.
 */
void dance_to_strip() {
    int dist = 1;
    int dir = 1;
    while(analog(OPTO_BACK_LEFT) > OPTO_THRESHOLD && analog(OPTO_BACK_RIGHT) > OPTO_THRESHOLD && dist < 19) {
        step_treads(dist * dir,-dist * dir);
        dist+=2;
        dir *= -1;
    }
}
