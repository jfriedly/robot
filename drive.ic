/**
 * @file util.ic
 * @brief Utility functions
 * @author Andrew Krieger
 * @date 4/25/2011
 */

#use "defines.ic"
#use "util.ic"
#use "line.ic"


/// Wait for this many loops to confirm we're over something shiny (ie, aluminum strips)
#define SHINY_TIME 2

///If the treads differ by this many counts while trying to drive straight, stop the advanced one
#define TREAD_DISPARITY 5

/**
 * @brief Drive up the hill
 */
void drive_up_hill() {
    //number of cycles for which the tested optosensors are over something shiny
    //The sensors will occasionally return low numbers when over a screw in the course
    // And sometimes
    int shiny_ctr;
    
    printf("Going up hill\n");
    
    //Drive across the bumps and up the hill - angle right when off wall
    motor(MOTOR_LEFT, 100);
    while(shiny_ctr < SHINY_TIME) {
        //If the switch is pressed, go straight.  Otherwise angle right.
        if(digital(FRONT_RIGHT_SWITCH))
          motor(MOTOR_RIGHT,100);
        else
          motor(MOTOR_RIGHT, 60);
        
        //Check the optos
        if(analog(OPTO_FRONT_RIGHT) < OPTO_THRESHOLD && analog(OPTO_FRONT_LEFT) < OPTO_THRESHOLD) {
            ++shiny_ctr;
        } else {
            shiny_ctr = 0;
        }
    }
    
    printf("Front on shiny\n");
    //Go straight (ish) until the front sensors are off the shiny
    motor(MOTOR_RIGHT, 100);
    while(analog(OPTO_FRONT_LEFT) < OPTO_THRESHOLD || analog(OPTO_FRONT_RIGHT) < OPTO_THRESHOLD)
      ;
    
    printf("Looking for back\n");
    //Go straight (ish) until the rear optos are on the shiny
    shiny_ctr = 0;
    while(shiny_ctr < SHINY_TIME) {
        if(analog(OPTO_BACK_RIGHT) < OPTO_THRESHOLD && analog(OPTO_BACK_LEFT) < OPTO_THRESHOLD) {
            ++shiny_ctr;
        } else {
            shiny_ctr = 0;
        }
    }
    
    //Stop
    ao();    
}

//Call this in a loop to drive straight backwards using the optos.
//Note: reset SHAFT_*_COUNT to zero first
void step_straight_back(int disparity) {
    int low_power;
    
    if(abs(SHAFT_LEFT_COUNT - SHAFT_RIGHT_COUNT) > disparity)
      low_power = 0;
    else
      low_power = 50;
    
    if(SHAFT_LEFT_COUNT > SHAFT_RIGHT_COUNT+1) {
        motor(MOTOR_LEFT,  -low_power);
        motor(MOTOR_RIGHT, -100);
        
    } else if(SHAFT_LEFT_COUNT < SHAFT_RIGHT_COUNT+1) {
        motor(MOTOR_LEFT, -100);
        motor(MOTOR_RIGHT, -low_power);
    } else {
        motor(MOTOR_LEFT,  -100);
        motor(MOTOR_RIGHT, -100);
    }
}

//Call this in a loop to drive straight forward using the optos.
//Note: reset SHAFT_*_COUNT to zero first
void step_straight_forward(void) {
    if(SHAFT_LEFT_COUNT > SHAFT_RIGHT_COUNT) {
        motor(MOTOR_LEFT,  70);
        motor(MOTOR_RIGHT, 100);
    } else if(SHAFT_LEFT_COUNT < SHAFT_RIGHT_COUNT) {
        motor(MOTOR_LEFT, 100);
        motor(MOTOR_RIGHT, 70);
    } else {
        motor(MOTOR_LEFT,  100);
        motor(MOTOR_RIGHT, 100);
    }
}

//Drive backwards until we hit a metal strip.  Stop with the back optos just past it.
void drive_back_to_shiny(void) {
    int shiny_ctr = 0;
    int high_water = 0;
    
    printf("Where's the shiny? Backward\n");
    
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    
    while(shiny_ctr < SHINY_TIME && !stop_button()) {
        if(analog(OPTO_BACK_LEFT) < OPTO_THRESHOLD && analog(OPTO_BACK_RIGHT) < OPTO_THRESHOLD) {
            ++shiny_ctr;
        } else {
            shiny_ctr = 0;
        }
        
        step_straight_back(2);
    }
    
    printf("Going til back off\n");
    //Continue until the back optos are off of the shiny
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    while(analog(OPTO_BACK_LEFT) < OPTO_THRESHOLD || analog(OPTO_BACK_RIGHT) < OPTO_THRESHOLD)
      step_straight_back(3);
    
    
    printf("Finding front optos\n");
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    shiny_ctr = 0;
    while(shiny_ctr < SHINY_TIME && !stop_button()) {
        if(analog(OPTO_FRONT_LEFT) < OPTO_THRESHOLD && analog(OPTO_FRONT_RIGHT) < OPTO_THRESHOLD) {
            ++shiny_ctr;
        } else {
            shiny_ctr = 0;
        }
        
        step_straight_back(3);
    }
    
    ao();
}

//Drive backwards until we hit a metal strip.  Stop with the back optos just past it.
void drive_forward_to_shiny(void) {
    int shiny_ctr = 0;
    int high_water = 0;
    
    printf("Where's the shiny? Forward\n");
    
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    
    while(shiny_ctr < SHINY_TIME && !stop_button()) {
        if(analog(OPTO_BACK_LEFT) < OPTO_THRESHOLD && analog(OPTO_BACK_RIGHT) < OPTO_THRESHOLD) {
            ++shiny_ctr;
        } else {
            shiny_ctr = 0;
        }
        
        step_straight_forward();
    }
    
    //Continue until the back optos are off of the shiny
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    while(analog(OPTO_BACK_LEFT) < OPTO_THRESHOLD || analog(OPTO_BACK_RIGHT) < OPTO_THRESHOLD)
      step_straight_back(5);
    
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    shiny_ctr = 0;
    while(shiny_ctr < SHINY_TIME && !stop_button()) {
        if(analog(OPTO_FRONT_LEFT) < OPTO_THRESHOLD && analog(OPTO_FRONT_RIGHT) < OPTO_THRESHOLD) {
            ++shiny_ctr;
        } else {
            shiny_ctr = 0;
        }
        
        step_straight_back(5);
    }
    
    ao();
}


void angle_right_to_shiny(void) {
    int shiny_ctr = 0;
    
    printf("Drive to shiny. Angle right\n");
    
    motor(MOTOR_LEFT, 100);
    motor(MOTOR_RIGHT, 80);
    
    while(shiny_ctr < SHINY_TIME && !stop_button()) {
        if(analog(OPTO_FRONT_LEFT) < OPTO_THRESHOLD && analog(OPTO_FRONT_RIGHT) < OPTO_THRESHOLD) {
            ++shiny_ctr;
        } else {
            shiny_ctr = 0;
        }
        
        if(mseconds() >= 50L) {
            printf("%d %d\n", analog(OPTO_FRONT_LEFT), analog(OPTO_FRONT_RIGHT));
            reset_system_time();
        }
        
    }
    
    ao();
    
}



/**
 * @brief Align self with metal strip
 * Not currently used.
 */
void drive_strip() {
    while(!stop_button()) {
        int i;
        
        for(i=2;i<7;++i) {
            printf("%d",i);
            print_hex_byte(analog(i));
            printf(" ");
        }
        
        printf("\n");
        sleep(0.1);
    }
}

/**
 * @brief Turn by deg, relative to current position
 * @param deg Degrees to turn.  Positive is CCW, negative is CW.
 *
 * This will repeatedly call [c]cw_degrees to turn.
 */
void turn(float deg) {
    if(deg > 0.0) {
        while(deg > 45.0) {
            ccw_degrees(45.0);
            deg -= 45.0;
        }
        
        ccw_degrees(deg);
    } else if(deg < 0.0) {
        while(deg < -45.0) {
            cw_degrees(45.0);
            deg += 45.0;
        }
        
        cw_degrees(-deg);
    }
}

///Helper function - best only for small angles (< 45 degrees)
void ccw_degrees(float deg) {
    int left_trans = round(deg * (70.0 / 360.0));
    int right_trans = round(deg * (124.0 / 360.0));
    
    printf("Turning %f deg\n", deg);
    
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    
    motor(MOTOR_LEFT, -100);
    motor(MOTOR_RIGHT, 100);
    
    while(((right_trans - SHAFT_RIGHT_COUNT) + (left_trans - SHAFT_LEFT_COUNT))/2 > 0)
      ;
    
    ao();
}

///Helper function - best only for small angles (<45 degrees)
void cw_degrees(float deg) {
    int left_trans = round(deg * (106.0 / 360.0));
    int right_trans = round(deg * (95.0 / 360.0));
    
    printf("Turning %f deg\n", deg);
    
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    
    motor(MOTOR_LEFT,  100);
    motor(MOTOR_RIGHT,-100);
    
    while(((right_trans - SHAFT_RIGHT_COUNT) + (left_trans - SHAFT_LEFT_COUNT))/2 > 0)
      ;
    
    ao();
}


void turn_cw_to_shiny(void) {
    while(analog(OPTO_FRONT_LEFT) > OPTO_THRESHOLD) {
        cw_degrees(10.0);
    }
}
