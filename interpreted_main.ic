/** 
 * @file   main.ic
 * @brief  Main loop
 * @author Andrew Krieger
 * @date   4/26/2011
 *
 */

#use "log.ic"
#use "util.ic"
#use "gps.ic"
#use "CdS.ic"
#use "turn.ic"

#define ACTION_HALT 0
#define ACTION_WAIT_FOR_START_LIGHT      1
#define ACTION_WAIT_FOR_START_BUTTON     2
#define ACTION_FROWARD_BY_KNOB           3
#define ACTION_CALIBRATE_GPS             4
#define ACTION_DRIVE_NORTH               5

#define ACTION_1ARG 100
#define ACTION_FORWARD_TO_GPS_Y(lim)     100, lim
#define ACTION_TURN_TO_ANGLE(ang)        101, ang
#define ACTION_FORWARD_BY_TRANSITIONS(t) 102, t

#define ACTION_2ARG 200
#define ACTION_DRIVE_TO_GPS(x,y)         200, x, y
#define ACTION_TURN_BY_TRANSITIONS(t,d)  201, t, d

#define MOTOR_LEFT  1
#define MOTOR_RIGHT 3

int ACTIONS[] = {
    ACTION_CALIBRATE_GPS,
      ACTION_WAIT_FOR_START_LIGHT,
      ACTION_DRIVE_NORTH,
      ACTION_TURN_TO_ANGLE(125),
      ACTION_FORWARD_BY_TRANSITIONS(85),
      ACTION_TURN_BY_TRANSITIONS(50, BACKWARDS),
      ACTION_TURN_BY_TRANSITIONS(10, CTRCLOCKWISE),
      ACTION_FORWARD_BY_TRANSITIONS(300),
      ACTION_HALT
  };

int halt = 0;

void calibrate_gps() {
    int btn;
    
    printf("START to finish GPS calibrating\n");
    sleep(0.25);
    gps_print_enable();
    
    for(;;) {
        btn = press_button();
        if(btn == BUTTON_START) {
            gps_print_disable();
            printf("Done calibrating.  Press start\n");
            press_start();
            return;
        } else {
            if(facing_north)
              facing_north = 0;
            else
              facing_north = 1;
        }
    }
}


#define BIG_ANGLE 15
#define ACCEPTABLE_ANGLE 5
//Temporary hack to get up ramp
void drive_north(void) {
    
    gps_y = 0;
    
    gps_print_enable();
    
    //> 256 is probaby an error - no GPS data; it seems to default to 288
    while(gps_y < 150 || gps_y > 256) {
        log_event(0x80, gps_y);
        //while(gps_time != mseconds())
        //;
        
        if(robot_heading > 180) {
            printf("PANIC!  Bad hdg %d\n", robot_heading);
            ao();
            for(;;)
              ;
        }
        
        if(robot_heading < 90 - ACCEPTABLE_ANGLE) {
            if(robot_heading < 90 - BIG_ANGLE) {
                motor(MOTOR_RIGHT, 75);
                motor(MOTOR_LEFT,  0);
            } else {
                motor(MOTOR_RIGHT, 100);
                motor(MOTOR_LEFT, 50);
            }
        } else if(robot_heading > 90 + ACCEPTABLE_ANGLE) {
            if(robot_heading > 90 + BIG_ANGLE) {
                motor(MOTOR_RIGHT,  0);
                motor(MOTOR_LEFT, 75);
            } else {
                motor(MOTOR_RIGHT, 50);
                motor(MOTOR_LEFT, 100);
            }
        } else {
            motor(MOTOR_RIGHT, 100);
            motor(MOTOR_LEFT,  100);
        }
        
        sleep(0.1);
    }                    
    
    log_event(0x85, gps_y);
    gps_print_disable();
}


int curr_action = 0;


void step(void) {
    int act, arg1, arg2;
    
    arg1 = arg2 = -1;
    
    act = ACTIONS[curr_action++];
    if(act >= ACTION_1ARG)
      arg1 = ACTIONS[curr_action++];
    if(act >= ACTION_2ARG)
      arg2 = ACTIONS[curr_action++];
    
    //    printf("Act: %d Arg1: %d Arg2: %d\n", act, arg1, arg2);
    //    press_start();
    
    switch(act) {
        case ACTION_HALT:
          halt = 1;
        break;
        
        case ACTION_WAIT_FOR_START_LIGHT:
          wait_for_start();
        break;
        
        case ACTION_WAIT_FOR_START_BUTTON:
          printf("   Waiting for     start btn\n");
        press_start();
        break;
        
        case ACTION_CALIBRATE_GPS:
          calibrate_gps();
        break;
        
        case ACTION_DRIVE_NORTH:
          drive_north();
        break;
        
        
        
        case 100: //ACTION_FORWARD_TO_GPS_Y
          //          forward_to_gps(arg1);
          break;
        
        case 101: //ACTION_TURN_TO_ANGLE
          turn_to_angle(arg1);
        break;
        
        case 102: //ACTION_FORWARD_BY_TRANSITIONS
          go_by_transitions(arg1, BOTH);
        break;
        
        case 200: //ACTION_DRIVE_TO_GPS
          //          drive_to_gps(arg1, arg2);
          break;
        
        case 201: //ACTION_TURN_BY_TRANSITIONS
          go_by_transitions(arg1, arg2);
        break;
    }        
}

void forward_by_knob(void) {
    int trans;
    int old_trans = -1;
    
    while(!start_button()) {
        trans = 170 + (knob() - 128)/8;
        if(trans != old_trans) {
            printf("T: %d\n", trans);
            old_trans = trans;
        }
    }
    
    go_by_transitions(trans, BOTH);
}

int main() { 
    int n = 0, d=-1;
    int last = digital(9);
    for(;;) {
        if(digital(9) != last) {
            ++n;
            last = !last;
        }
        if(stop_button())
          n = 0;
        
        if(n != d) {
            printf("%d\n", n);
            d = n;
        }
    }
    
    for(;;) {
        init_log();
        init_bkgd_gps();
        
        while(!halt)
          step();
        
        kill_bkgd_gps();
        printf("Halted:         Press START\n");
        press_start();
    }
}
