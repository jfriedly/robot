#use "util.ic"

#use "defines.ic"



#ifndef USE_OLD_DRIVE_STRAIGHT

void drive_straight(int trans) {
    int dir;
    int low_pwr;
    int diff;
    
    if(trans == 0)
      return;
    
    dir = trans / abs(trans);
    
    //Set trans = 2*abs(trans), so we can drive until avg(left, right) < trans   <=>    left+right < 2*trans
    trans = abs(trans);
    trans += trans;
    
    reset_system_time();
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    
    while(SHAFT_LEFT_COUNT + SHAFT_RIGHT_COUNT < trans && mseconds() < 5000L) {
        diff = abs(SHAFT_LEFT_COUNT - SHAFT_RIGHT_COUNT);
        if(diff > 5)
          low_pwr = 0;
        else if(diff > 3)
          low_pwr = 60;
        else if(diff > 1)
          low_pwr = 80;
        else
          low_pwr = 100;
        
        if(SHAFT_LEFT_COUNT > SHAFT_RIGHT_COUNT) {
            motor(MOTOR_LEFT, dir * low_pwr);
            motor(MOTOR_RIGHT, dir * 100);
        } else {
            motor(MOTOR_LEFT, dir * 100);
            motor(MOTOR_RIGHT, dir * low_pwr);
        }
    }
    
    ao();
    
}

#else

#define MOTOR_LEFT 1
#define MOTOR_RIGHT 3


/**
 * @brief Drive forward or backward in a straight line.  Negative distances are backwards.
 * @param trans Number of transitions to drive for.
 * 
 * The code uses this strategy:
 *   Step up the motors to full power, over the course of half a second.
 *   Drive at full power until within a few transitions of the given distance
 *   Step down the motors, then run slowly to the finish
 * Throughout the routine, if one tread gets 2 transitions beyond the other, the one in front
 * is run at 75% of its current power.  This should compensate for uneven distances.
 */
void drive_straight(int trans) {
    // Direction - 1 for forward, 0 for backward
    int dir;
    // Percentage of power, for step up/down
    int pct;
    // Time to step up/down at
    long step_time;
    // Are we stepping up (1) or down (-1), or neither (0)
    int state;
    // Run left or right at reduced power (3) or full power (4)
    int left_mult, right_mult;
    //Completion "percentage" (actually per 10000)
    int left_comp, right_comp;
    
    float l_scale = 10000.0 / ((float)trans);
    float r_scale = 10000.0 / ((float)trans);
    
    if(trans == 0)
      return;
    dir = trans/abs(trans);
    pct = 40;
    state =0;
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    step_time = mseconds() + 100L;
    
    for(;;) {
        left_comp = (int)((float)SHAFT_LEFT_COUNT * l_scale);
        right_comp = (int)((float)SHAFT_RIGHT_COUNT * r_scale);
        
        switch(state)
          {
            case 0:
              {
                if(mseconds() >= step_time) {
                    step_time = mseconds() + 100L;
                    pct += 20;
                    if(pct == 100)
                      state = 1;
                }
                break;
            }
            case 1:
              {
                if((SHAFT_LEFT_COUNT + SHAFT_RIGHT_COUNT)/2 >= abs(trans) - 15) {
                    state = 2;
                    step_time = mseconds() + 100L;
                    pct = 80;
                }
                break;
            }
            case 2:
              {
                if(mseconds() >= step_time) {
                    step_time = mseconds() + 100L;
                    pct -= 20;
                    if(pct == 40)
                      state = 3;
                }
            }
            case 3:
              {
                if((left_comp + right_comp)/2 >= 100) {
                    ao();
                    return;
                }
            }
            default:
              {
                ao();
                return;
            }
        }
        
        left_mult = right_mult = 4;
        //A 2% difference
        if(left_comp > right_comp + 200) {
            left_mult = 3;
            printf("L\n");
        } else if(right_comp > left_comp + 200) {
            right_mult = 3;
            printf("R\n");
        }
        
        motor(MOTOR_LEFT, dir * pct * left_mult / 4);
        motor(MOTOR_RIGHT, dir * pct * right_mult / 4);
    }
}



/**
 * @brief Get conversion factor for inches -> transitions
 * @param inches The number of inches to drive
 *
 * This equation was determined experimentally.
 * 
 * The following data set:
 *   <pre> {
 *   (4, 7.484375),
 *   (5, 6.75),
 *   (6, 6.34375),
 *   (7, 6.125),
 *   (8, 5.90625),
 *   (10,5.8125),
 *   (12,5.703125),
 *   (16,5.5),
 *   (20,5.3),
 *   (24,5.203125)
 *  }</pre>
 * was approximated by a power regression on a TI-84.
 * At 3:00AM, we tried again.  Now it was undershooting.  A linear regression
 * inspired us to compose a linear function of one real variable with the previous
 * power function.
 */
float calc_conv_factor(float inches) {
    //return 6.0;
    float x;
    x = (8.9495 * (inches ^ -0.17896)) * 1.17010+ 0.63118;
    x= 0.002599 * x * x + 0.710097 * x + 0.53677;
    return x * 1.1;
}


/**
 * @brief Drive in a straight line.  Distance in inches.
 * @param inches The distance to drive.  Negative to go backwards.
 */ 
void drive_straight_inches(float inches) {
    //Numerical factor determined by experimentation.
    drive_straight((int)(inches * calc_conv_factor(fabs(inches))));
}

// Fairly consistent average at 110 transitions per 2*pi.
// Right tread was ~80 trans behind left at three circles.  Maybe batteries, maybe rubber, maybe cosmic rays.
// Stupid real world messing with mah codez.

/*
int main() {
    float disp;
    float dist;
    
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    
    for(;;) {
        disp = -1.;
        
        while(!start_button()) {
            dist = 36. + (float)(knob()-128)/4.;
            if(disp != dist) {
                printf("Dist: %f\n", dist);
                disp = dist;
            }
        }
        
        drive_straight_inches(dist);
    }
}
*/

#endif
