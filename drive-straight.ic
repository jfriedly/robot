#use "util.ic"

#use "encoders.ic"

#define MOTOR_LEFT 1
#define MOTOR_RIGHT 3


/**
 * @brief Drive forward or backward in a straight line.  Negative distances are backwards.
 * @param trans Number of transitions to drive for.
 * 
 * The code uses this strategy:
 *   Step up the motors to full power, over the course of half a second.
 *   Drive at full power until within a few transitions of the given distance
 *   Step down the motors, then run slowly to the finish
 * Throughout the routine, if one tread gets 2 transitions beyond the other, the one in front
 * is run at 75% of its current power.  This should compensate for uneven distances.
 */
void drive_straight(int trans) {
    // Direction - 1 for forward, 0 for backward
    int dir;
    // Percentage of power, for step up/down
    int pct;
    // Time to step up/down at
    long step_time;
    // Are we stepping up (1) or down (-1), or neither (0)
    int up_or_down;
    // Run left or right at reduced power (3) or full power (4)
    int left_mult, right_mult;
    //Completion "percentage" (actually per 10000)
    int left_comp, right_comp;
    
    float l_scale = 10000.0 / ((float)trans);
    float r_scale = 10000.0 / ((float)trans * 1.1);
    
    if(trans == 0)
      return;
    dir = trans/abs(trans);
    pct = 40;
    up_or_down = 1;
    SHAFT_LEFT_COUNT = SHAFT_RIGHT_COUNT = 0;
    step_time = mseconds() + 100L;
    
    for(;;) {
        left_comp = (int)((float)SHAFT_LEFT_COUNT * l_scale);
        right_comp = (int)((float)SHAFT_RIGHT_COUNT * r_scale);
        
        switch(up_or_down)
          {
            case 1:
              {
                if(mseconds() >= step_time) {
                    step_time = mseconds() + 100L;
                    pct += 20;
                    if(pct == 100)
                      up_or_down = 0;
                }
                break;
            }
            case 0:
              {
                if((SHAFT_LEFT_COUNT + SHAFT_RIGHT_COUNT)/2 >= abs(trans) - 15) {
                    up_or_down = -1;
                    step_time = mseconds() + 100L;
                    pct = 80;
                }
                break;
            }
            case -1:
              {
                if(mseconds() >= step_time) {
                    step_time = mseconds() + 100L;
                    pct -= 20;
                    if(pct == 40)
                      up_or_down = -2;
                }
            }
            case -2:
              {
                if((left_comp + right_comp)/2 >= 100) {
                    ao();
                    return;
                }
            }
            default:
              {
                ao();
                return;
            }
        }
        
        left_mult = right_mult = 4;
        //A 2% difference
        if(left_comp > right_comp + 200) {
            left_mult = 3;
            printf("L\n");
        } else if(right_comp > left_comp + 200) {
            right_mult = 3;
            printf("R\n");
        }
        
        motor(MOTOR_LEFT, pct * left_mult / 4);
        motor(MOTOR_RIGHT, pct * right_mult / 4);
    }
}



/**
 * @brief Get conversion factor for inches -> transitions
 * @param inches The number of inches to drive
 *
 * This equation was determined experimentally.
 * 
 * The following data set:
 *   <pre> {
 *   (4, 7.484375),
 *   (5, 6.75),
 *   (6, 6.34375),
 *   (7, 6.125),
 *   (8, 5.90625),
 *   (10,5.8125),
 *   (12,5.703125),
 *   (16,5.5),
 *   (20,5.3),
 *   (24,5.203125)
 *  }</pre>
 * was approximated by a power regression on a TI-84.
 */
float calc_conv_factor(float inches) {
    return 8.9495 * (inches ^ -0.17896);
}


/**
 * @brief Drive in a straight line.  Distance in inches.
 * @param inches The distance to drive.  Negative to go backwards.
 */ 
void drive_straight_inches(float inches) {
    //Numerical factor determined by experimentation.
    drive_straight((int)(inches * calc_conv_factor(fabs(inches))));
}
